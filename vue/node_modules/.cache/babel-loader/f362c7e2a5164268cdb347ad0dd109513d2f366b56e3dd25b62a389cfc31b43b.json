{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport request from \"@/utils/request\";\nexport default {\n  data() {\n    return {\n      websocket: null\n    };\n  },\n  methods: {\n    initializeWebSocket(userId) {\n      this.websocket = new WebSocket(`ws://localhost:9090/imserverSingle/${userId}`);\n      this.websocket.onopen = this.onWebSocketOpen;\n      this.websocket.onclose = this.onWebSocketClose;\n      this.websocket.onmessage = this.onWebSocketMessage;\n    },\n    onWebSocketOpen() {\n      console.log('WebSocket连接已打开');\n      // 连接成功后的逻辑，例如获取初始数据\n    },\n\n    onWebSocketClose() {\n      console.log('WebSocket连接已关闭');\n      // 连接关闭后的逻辑\n    },\n\n    onWebSocketMessage(msg) {\n      if (msg.data) {\n        // 检查接收到的消息是否存在。\n        let json = JSON.parse(msg.data);\n        if (json.users && json.users.length) {\n          this.loadOnline(json);\n          return;\n        }\n        if (json.content && json.fromuser === this.fromUser.toString() && json.touser === this.toUser.toString() || json.touser === this.fromUser.toString() && json.fromuser === this.toUser.toString()) {\n          // 说明是两者互相发消息\n          this.messages.push(json); //放到消息队列里\n          this.scrollToBottom(); // 滚动页面到最底部\n        }\n        // 加载消息数字 两者通信如果是对面发来的消息 说明当前正在两个人的通信窗口\n        if (this.toUser.toString() === json.fromuser) {\n          this.setUnReadNums(); // 把对方消息设为已读,更新未读消息数量\n        } else {\n          //用户发给对方的\n          // 可能是当前用户发给对方的消息，或者是其他人通信 都 加载当前用户的未读消息数量 每次监听到通信事件就更新未读记录\n          this.loadUnReadNums();\n        }\n      }\n      // 处理收到的WebSocket消息\n    },\n\n    shouldDisplayTime(index, group) {\n      if (index === 0) {\n        return true;\n      }\n      const currentTime = new Date(group[index].time).getTime();\n      const prevTime = new Date(group[index - 1].time).getTime();\n      return currentTime - prevTime > this.timeIntervalThreshold;\n    },\n    load() {\n      request.get('/imsingle?fromUser=' + this.fromUser.toString() + '&toUser=' + this.toUser.toString()).then(res => {\n        // console.log(res)\n        if (res.code === '200') {\n          //把对方消息设为已读 这是两者的消息传递\n          this.messages = res.data;\n          this.scrollToBottom(); // 滚动条滚动到最底部\n        } else {\n          this.$notify.error(res.msg);\n        }\n        this.loadUnReadNums();\n      });\n    },\n    // 查询两个人的所有消息 同时把 对方 的消息设为已读\n    setUnReadNums() {\n      request.get('/imsingle?fromUser=' + this.fromUser.toString() + '&toUser=' + this.toUser.toString()).then(res => {\n        this.loadUnReadNums();\n      });\n    },\n    // 查询当前用户的所有未读数量并标记\n    loadUnReadNums() {\n      request.get('/imsingle/unReadNums?toUsername=' + this.fromUser.toString()).then(res => {\n        this.unRead = res.data;\n        // console.log(this.unRead)STUDENT_池:2\n      });\n    },\n\n    //查询所有的在线人数\n    loadOnline() {\n      // 查询用户是否在线\n\n      request.get('/user/selectAllOnline').then(res => {\n        //过滤掉自己就可以 //实时刷新\n        res.data = res.data.filter(v => v.id !== this.user.id);\n        this.$set(this.users, 'USER', res.data);\n      });\n    },\n    //发送消息\n    send() {\n      if (!this.toUser) {\n        this.$notify.error('请选择聊天用户');\n        return;\n      }\n      if (client) {\n        let message = this.getMessage('text');\n        client.send(JSON.stringify(message));\n      }\n      document.getElementById('im-content').innerHTML = ''; // 清空输入框\n    },\n\n    //选择对方并查询两个人的所有消息 同时把 对方 的消息设为已读 更新所有未读记录\n    selectToUser(item) {\n      //设置发送的人以及对方的头像\n      this.toUserName = item.name;\n      this.toUser = item.id;\n      this.toAvatar = item.avatar;\n      //查询聊天记录 同时把对方消息的设为已读\n      this.load();\n    },\n    //下载文件\n    download(file) {\n      window.open(file);\n    },\n    //发送的信息\n    getMessage(type) {\n      let inputBox = document.getElementById('im-content'); //输入框输入的东西进行获取\n      const content = inputBox.innerHTML;\n      if (!content && type === 'text') {\n        //没有聊天内容\n        this.$notify.error('请输入聊天内容');\n        return;\n      }\n      return {\n        fromuser: this.fromUser,\n        //自己\n        fromavatar: this.user.avatar,\n        touser: this.toUser,\n        toavatar: this.toAvatar,\n        content: content,\n        type: type\n      };\n    },\n    // 设置文件类型 是图片还是文件 发送文件\n    handleFile(file) {\n      if (client) {\n        let message = this.getMessage('img');\n        message.content = file.data;\n        //这是一个地址\n        let extName = file.data.substring(file.data.lastIndexOf('.') + 1);\n        if (['png', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'svg', 'webp'].includes(extName)) {\n          message.type = 'img';\n        } else {\n          message.type = 'file';\n        }\n        client.send(JSON.stringify(message));\n      }\n    },\n    //设置发送的表情\n    clickEmoji(emoji) {\n      document.getElementById('im-content').innerHTML += emoji;\n    },\n    //滚动到最底部\n    scrollToBottom() {\n      this.$nextTick(() => {\n        // 设置聊天滚动条到底部\n        let imMessageBox = document.getElementsByClassName(\"im-message-box\")[0];\n        //设置滚动条到最底部\n        imMessageBox.scrollTop = imMessageBox.scrollHeight;\n        console.log('触发滚动');\n      });\n    }\n\n    // 其他WebSocket相关方法和逻辑\n  },\n\n  // 在组件销毁前关闭WebSocket连接\n  beforeDestroy() {\n    if (this.websocket) {\n      this.websocket.close();\n    }\n  }\n};","map":{"version":3,"names":["request","data","websocket","methods","initializeWebSocket","userId","WebSocket","onopen","onWebSocketOpen","onclose","onWebSocketClose","onmessage","onWebSocketMessage","console","log","msg","json","JSON","parse","users","length","loadOnline","content","fromuser","fromUser","toString","touser","toUser","messages","push","scrollToBottom","setUnReadNums","loadUnReadNums","shouldDisplayTime","index","group","currentTime","Date","time","getTime","prevTime","timeIntervalThreshold","load","get","then","res","code","$notify","error","unRead","filter","v","id","user","$set","send","client","message","getMessage","stringify","document","getElementById","innerHTML","selectToUser","item","toUserName","name","toAvatar","avatar","download","file","window","open","type","inputBox","fromavatar","toavatar","handleFile","extName","substring","lastIndexOf","includes","clickEmoji","emoji","$nextTick","imMessageBox","getElementsByClassName","scrollTop","scrollHeight","beforeDestroy","close"],"sources":["C:/Users/wcf/springboot-vue框架实操/xm-blog/vue/src/store/websocketMixin.js"],"sourcesContent":["import request from \"@/utils/request\";\r\n\r\nexport default {\r\n    data() {\r\n        return {\r\n            websocket: null,\r\n        };\r\n    },\r\n    methods: {\r\n        initializeWebSocket(userId) {\r\n            this.websocket = new WebSocket(`ws://localhost:9090/imserverSingle/${userId}`);\r\n            this.websocket.onopen = this.onWebSocketOpen;\r\n            this.websocket.onclose = this.onWebSocketClose;\r\n            this.websocket.onmessage = this.onWebSocketMessage;\r\n        },\r\n        onWebSocketOpen() {\r\n            console.log('WebSocket连接已打开');\r\n            // 连接成功后的逻辑，例如获取初始数据\r\n        },\r\n        onWebSocketClose() {\r\n            console.log('WebSocket连接已关闭');\r\n            // 连接关闭后的逻辑\r\n        },\r\n        onWebSocketMessage(msg) {\r\n            if (msg.data) { // 检查接收到的消息是否存在。\r\n                let json = JSON.parse(msg.data)\r\n                if (json.users && json.users.length){\r\n                    this.loadOnline(json);\r\n                    return\r\n                }\r\n                if (json.content && (json.fromuser === this.fromUser.toString() && json.touser === this.toUser.toString())\r\n                    || json.touser === this.fromUser.toString() && json.fromuser === this.toUser.toString()) {  // 说明是两者互相发消息\r\n                    this.messages.push(json) //放到消息队列里\r\n                    this.scrollToBottom()  // 滚动页面到最底部\r\n                }\r\n                // 加载消息数字 两者通信如果是对面发来的消息 说明当前正在两个人的通信窗口\r\n                if (this.toUser.toString() === json.fromuser) {\r\n                    this.setUnReadNums()  // 把对方消息设为已读,更新未读消息数量\r\n                } else {  //用户发给对方的\r\n                    // 可能是当前用户发给对方的消息，或者是其他人通信 都 加载当前用户的未读消息数量 每次监听到通信事件就更新未读记录\r\n                    this.loadUnReadNums()\r\n                }\r\n            }\r\n            // 处理收到的WebSocket消息\r\n        },\r\n        shouldDisplayTime(index, group) {\r\n            if (index === 0) {\r\n                return true;\r\n            }\r\n            const currentTime = new Date(group[index].time).getTime();\r\n            const prevTime = new Date(group[index - 1].time).getTime();\r\n            return currentTime - prevTime > this.timeIntervalThreshold;\r\n        },\r\n\r\n        load() {\r\n            request.get('/imsingle?fromUser=' + this.fromUser.toString() + '&toUser=' + this.toUser.toString()).then(res => {\r\n                // console.log(res)\r\n                if (res.code === '200') {\r\n                    //把对方消息设为已读 这是两者的消息传递\r\n                    this.messages = res.data\r\n                    this.scrollToBottom()  // 滚动条滚动到最底部\r\n                } else {\r\n                    this.$notify.error(res.msg)\r\n                }\r\n                this.loadUnReadNums()\r\n            })\r\n        },\r\n        // 查询两个人的所有消息 同时把 对方 的消息设为已读\r\n        setUnReadNums() {\r\n            request.get('/imsingle?fromUser=' + this.fromUser.toString() + '&toUser=' + this.toUser.toString()).then(res => {\r\n                this.loadUnReadNums()\r\n            })\r\n        },\r\n        // 查询当前用户的所有未读数量并标记\r\n        loadUnReadNums() {\r\n            request.get('/imsingle/unReadNums?toUsername=' + this.fromUser.toString()).then(res => {\r\n                this.unRead = res.data\r\n                // console.log(this.unRead)STUDENT_池:2\r\n            })\r\n        },\r\n        //查询所有的在线人数\r\n        loadOnline(){\r\n            // 查询用户是否在线\r\n\r\n            request.get('/user/selectAllOnline').then(res => {\r\n                //过滤掉自己就可以 //实时刷新\r\n                res.data = res.data.filter(v => v.id  !== this.user.id )\r\n                this.$set(this.users, 'USER', res.data)\r\n            })\r\n        },\r\n\r\n        //发送消息\r\n        send() {\r\n            if (!this.toUser) {\r\n                this.$notify.error('请选择聊天用户')\r\n                return\r\n            }\r\n            if (client) {\r\n                let message = this.getMessage('text')\r\n                client.send(JSON.stringify(message))\r\n            }\r\n            document.getElementById('im-content').innerHTML = ''  // 清空输入框\r\n        },\r\n        //选择对方并查询两个人的所有消息 同时把 对方 的消息设为已读 更新所有未读记录\r\n        selectToUser(item) {\r\n            //设置发送的人以及对方的头像\r\n            this.toUserName = item.name\r\n            this.toUser = item.id\r\n            this.toAvatar = item.avatar\r\n            //查询聊天记录 同时把对方消息的设为已读\r\n            this.load()\r\n        },\r\n        //下载文件\r\n        download(file) {\r\n            window.open(file)\r\n        },\r\n        //发送的信息\r\n        getMessage(type) {\r\n            let inputBox = document.getElementById('im-content') //输入框输入的东西进行获取\r\n            const content = inputBox.innerHTML\r\n            if (!content && type === 'text') { //没有聊天内容\r\n                this.$notify.error('请输入聊天内容')\r\n                return\r\n            }\r\n            return {\r\n                fromuser: this.fromUser,//自己\r\n                fromavatar: this.user.avatar,\r\n                touser: this.toUser,\r\n                toavatar: this.toAvatar,\r\n                content: content,\r\n                type: type\r\n            }\r\n        },\r\n        // 设置文件类型 是图片还是文件 发送文件\r\n        handleFile(file) {\r\n            if (client) {\r\n                let message = this.getMessage('img')\r\n                message.content = file.data\r\n                //这是一个地址\r\n                let extName = file.data.substring(file.data.lastIndexOf('.') + 1)\r\n                if (['png', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'svg', 'webp'].includes(extName)) {\r\n                    message.type = 'img'\r\n                } else {\r\n                    message.type = 'file'\r\n                }\r\n                client.send(JSON.stringify(message))\r\n            }\r\n        },\r\n        //设置发送的表情\r\n        clickEmoji(emoji) {\r\n            document.getElementById('im-content').innerHTML += emoji\r\n        },\r\n        //滚动到最底部\r\n        scrollToBottom() {\r\n            this.$nextTick(() => {\r\n                // 设置聊天滚动条到底部\r\n                let imMessageBox = document.getElementsByClassName(\"im-message-box\")[0]\r\n                //设置滚动条到最底部\r\n                imMessageBox.scrollTop = imMessageBox.scrollHeight\r\n                console.log('触发滚动')\r\n            })\r\n        },\r\n\r\n        // 其他WebSocket相关方法和逻辑\r\n    },\r\n    // 在组件销毁前关闭WebSocket连接\r\n    beforeDestroy() {\r\n        if (this.websocket) {\r\n            this.websocket.close();\r\n        }\r\n    },\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}