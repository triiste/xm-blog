{"ast":null,"code":"import { isSpace, normalizeReference } from '../common/utils.mjs';\nexport default function reference(state, startLine, _endLine, silent) {\n  let lines = 0;\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n  let nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {\n    return false;\n  }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ && state.src.charCodeAt(pos - 1) !== 0x5C /* \\ */) {\n      if (pos + 1 === max) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A /* : */) {\n        return false;\n      }\n      break;\n    }\n  }\n  const endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  const terminatorRules = state.md.block.ruler.getRules('reference');\n  const oldParentType = state.parentType;\n  state.parentType = 'reference';\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false;\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  const str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n  let labelEnd = -1;\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n    return false;\n  }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!destRes.ok) {\n    return false;\n  }\n  const href = state.md.normalizeLink(destRes.str);\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n  pos = destRes.pos;\n  lines += destRes.lines;\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos;\n  const destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos;\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  const titleRes = state.md.helpers.parseLinkTitle(str, pos, max);\n  let title;\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str;\n    pos = titleRes.pos;\n    lines += titleRes.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      break;\n    }\n    pos++;\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        const ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n        pos++;\n      }\n    }\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n  const label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) {\n    return true;\n  }\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title,\n      href\n    };\n  }\n  state.parentType = oldParentType;\n  state.line = startLine + lines + 1;\n  return true;\n}","map":{"version":3,"names":["isSpace","normalizeReference","reference","state","startLine","_endLine","silent","lines","pos","bMarks","tShift","max","eMarks","nextLine","sCount","blkIndent","src","charCodeAt","endLine","lineMax","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","isEmpty","terminate","i","l","length","str","getLines","trim","labelEnd","ch","destRes","helpers","parseLinkDestination","ok","href","normalizeLink","validateLink","destEndPos","destEndLineNo","start","titleRes","parseLinkTitle","title","label","slice","env","references","line"],"sources":["C:/Users/wcf/springboot-vue框架实操/xm-blog/vue/node_modules/markdown-it/lib/rules_block/reference.mjs"],"sourcesContent":["import { isSpace, normalizeReference } from '../common/utils.mjs'\n\nexport default function reference (state, startLine, _endLine, silent) {\n  let lines = 0\n\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false }\n      break\n    }\n  }\n\n  const endLine = state.lineMax\n\n  // jump line-by-line until empty one or EOF\n  const terminatorRules = state.md.block.ruler.getRules('reference')\n\n  const oldParentType = state.parentType\n  state.parentType = 'reference'\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  const str = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      lines++\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      lines++\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n  lines += destRes.lines\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = lines\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      lines++\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  const titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n    lines += titleRes.lines\n  } else {\n    title = ''\n    pos = destEndPos\n    lines = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      lines = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!isSpace(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.parentType = oldParentType\n\n  state.line = startLine + lines + 1\n  return true\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,kBAAkB,QAAQ,qBAAqB;AAEjE,eAAe,SAASC,SAASA,CAAEC,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EACrE,IAAIC,KAAK,GAAG,CAAC;EAEb,IAAIC,GAAG,GAAGL,KAAK,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGD,KAAK,CAACO,MAAM,CAACN,SAAS,CAAC;EAC3D,IAAIO,GAAG,GAAGR,KAAK,CAACS,MAAM,CAACR,SAAS,CAAC;EACjC,IAAIS,QAAQ,GAAGT,SAAS,GAAG,CAAC;;EAE5B;EACA,IAAID,KAAK,CAACW,MAAM,CAACV,SAAS,CAAC,GAAGD,KAAK,CAACY,SAAS,IAAI,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAEnE,IAAIZ,KAAK,CAACa,GAAG,CAACC,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,UAAS;IAAE,OAAO,KAAK;EAAC;;EAE9D;EACA;EACA,OAAO,EAAEA,GAAG,GAAGG,GAAG,EAAE;IAClB,IAAIR,KAAK,CAACa,GAAG,CAACC,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,CAAC,WACnCL,KAAK,CAACa,GAAG,CAACC,UAAU,CAACT,GAAG,GAAG,CAAC,CAAC,KAAK,IAAI,UAAS;MACjD,IAAIA,GAAG,GAAG,CAAC,KAAKG,GAAG,EAAE;QAAE,OAAO,KAAK;MAAC;MACpC,IAAIR,KAAK,CAACa,GAAG,CAACC,UAAU,CAACT,GAAG,GAAG,CAAC,CAAC,KAAK,IAAI,UAAS;QAAE,OAAO,KAAK;MAAC;MAClE;IACF;EACF;EAEA,MAAMU,OAAO,GAAGf,KAAK,CAACgB,OAAO;;EAE7B;EACA,MAAMC,eAAe,GAAGjB,KAAK,CAACkB,EAAE,CAACC,KAAK,CAACC,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;EAElE,MAAMC,aAAa,GAAGtB,KAAK,CAACuB,UAAU;EACtCvB,KAAK,CAACuB,UAAU,GAAG,WAAW;EAE9B,OAAOb,QAAQ,GAAGK,OAAO,IAAI,CAACf,KAAK,CAACwB,OAAO,CAACd,QAAQ,CAAC,EAAEA,QAAQ,EAAE,EAAE;IACjE;IACA;IACA,IAAIV,KAAK,CAACW,MAAM,CAACD,QAAQ,CAAC,GAAGV,KAAK,CAACY,SAAS,GAAG,CAAC,EAAE;MAAE;IAAS;;IAE7D;IACA,IAAIZ,KAAK,CAACW,MAAM,CAACD,QAAQ,CAAC,GAAG,CAAC,EAAE;MAAE;IAAS;;IAE3C;IACA,IAAIe,SAAS,GAAG,KAAK;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGV,eAAe,CAACW,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACtD,IAAIT,eAAe,CAACS,CAAC,CAAC,CAAC1B,KAAK,EAAEU,QAAQ,EAAEK,OAAO,EAAE,IAAI,CAAC,EAAE;QACtDU,SAAS,GAAG,IAAI;QAChB;MACF;IACF;IACA,IAAIA,SAAS,EAAE;MAAE;IAAM;EACzB;EAEA,MAAMI,GAAG,GAAG7B,KAAK,CAAC8B,QAAQ,CAAC7B,SAAS,EAAES,QAAQ,EAAEV,KAAK,CAACY,SAAS,EAAE,KAAK,CAAC,CAACmB,IAAI,CAAC,CAAC;EAC9EvB,GAAG,GAAGqB,GAAG,CAACD,MAAM;EAChB,IAAII,QAAQ,GAAG,CAAC,CAAC;EAEjB,KAAK3B,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IAC9B,MAAM4B,EAAE,GAAGJ,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI4B,EAAE,KAAK,IAAI,CAAC,SAAS;MACvB,OAAO,KAAK;IACd,CAAC,MAAM,IAAIA,EAAE,KAAK,IAAI,CAAC,SAAS;MAC9BD,QAAQ,GAAG3B,GAAG;MACd;IACF,CAAC,MAAM,IAAI4B,EAAE,KAAK,IAAI,CAAC,UAAU;MAC/B7B,KAAK,EAAE;IACT,CAAC,MAAM,IAAI6B,EAAE,KAAK,IAAI,CAAC,SAAS;MAC9B5B,GAAG,EAAE;MACL,IAAIA,GAAG,GAAGG,GAAG,IAAIqB,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;QAC7CD,KAAK,EAAE;MACT;IACF;EACF;EAEA,IAAI4B,QAAQ,GAAG,CAAC,IAAIH,GAAG,CAACf,UAAU,CAACkB,QAAQ,GAAG,CAAC,CAAC,KAAK,IAAI,UAAS;IAAE,OAAO,KAAK;EAAC;;EAEjF;EACA;EACA,KAAK3B,GAAG,GAAG2B,QAAQ,GAAG,CAAC,EAAE3B,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IACzC,MAAM4B,EAAE,GAAGJ,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI4B,EAAE,KAAK,IAAI,EAAE;MACf7B,KAAK,EAAE;IACT,CAAC,MAAM,IAAIP,OAAO,CAACoC,EAAE,CAAC,EAAE;MACtB;IAAA,CACD,MAAM;MACL;IACF;EACF;;EAEA;EACA;EACA,MAAMC,OAAO,GAAGlC,KAAK,CAACkB,EAAE,CAACiB,OAAO,CAACC,oBAAoB,CAACP,GAAG,EAAExB,GAAG,EAAEG,GAAG,CAAC;EACpE,IAAI,CAAC0B,OAAO,CAACG,EAAE,EAAE;IAAE,OAAO,KAAK;EAAC;EAEhC,MAAMC,IAAI,GAAGtC,KAAK,CAACkB,EAAE,CAACqB,aAAa,CAACL,OAAO,CAACL,GAAG,CAAC;EAChD,IAAI,CAAC7B,KAAK,CAACkB,EAAE,CAACsB,YAAY,CAACF,IAAI,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAEjDjC,GAAG,GAAG6B,OAAO,CAAC7B,GAAG;EACjBD,KAAK,IAAI8B,OAAO,CAAC9B,KAAK;;EAEtB;EACA,MAAMqC,UAAU,GAAGpC,GAAG;EACtB,MAAMqC,aAAa,GAAGtC,KAAK;;EAE3B;EACA;EACA,MAAMuC,KAAK,GAAGtC,GAAG;EACjB,OAAOA,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IACvB,MAAM4B,EAAE,GAAGJ,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI4B,EAAE,KAAK,IAAI,EAAE;MACf7B,KAAK,EAAE;IACT,CAAC,MAAM,IAAIP,OAAO,CAACoC,EAAE,CAAC,EAAE;MACtB;IAAA,CACD,MAAM;MACL;IACF;EACF;;EAEA;EACA;EACA,MAAMW,QAAQ,GAAG5C,KAAK,CAACkB,EAAE,CAACiB,OAAO,CAACU,cAAc,CAAChB,GAAG,EAAExB,GAAG,EAAEG,GAAG,CAAC;EAC/D,IAAIsC,KAAK;EAET,IAAIzC,GAAG,GAAGG,GAAG,IAAImC,KAAK,KAAKtC,GAAG,IAAIuC,QAAQ,CAACP,EAAE,EAAE;IAC7CS,KAAK,GAAGF,QAAQ,CAACf,GAAG;IACpBxB,GAAG,GAAGuC,QAAQ,CAACvC,GAAG;IAClBD,KAAK,IAAIwC,QAAQ,CAACxC,KAAK;EACzB,CAAC,MAAM;IACL0C,KAAK,GAAG,EAAE;IACVzC,GAAG,GAAGoC,UAAU;IAChBrC,KAAK,GAAGsC,aAAa;EACvB;;EAEA;EACA,OAAOrC,GAAG,GAAGG,GAAG,EAAE;IAChB,MAAMyB,EAAE,GAAGJ,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI,CAACR,OAAO,CAACoC,EAAE,CAAC,EAAE;MAAE;IAAM;IAC1B5B,GAAG,EAAE;EACP;EAEA,IAAIA,GAAG,GAAGG,GAAG,IAAIqB,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;IAC7C,IAAIyC,KAAK,EAAE;MACT;MACA;MACAA,KAAK,GAAG,EAAE;MACVzC,GAAG,GAAGoC,UAAU;MAChBrC,KAAK,GAAGsC,aAAa;MACrB,OAAOrC,GAAG,GAAGG,GAAG,EAAE;QAChB,MAAMyB,EAAE,GAAGJ,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC;QAC9B,IAAI,CAACR,OAAO,CAACoC,EAAE,CAAC,EAAE;UAAE;QAAM;QAC1B5B,GAAG,EAAE;MACP;IACF;EACF;EAEA,IAAIA,GAAG,GAAGG,GAAG,IAAIqB,GAAG,CAACf,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;IAC7C;IACA,OAAO,KAAK;EACd;EAEA,MAAM0C,KAAK,GAAGjD,kBAAkB,CAAC+B,GAAG,CAACmB,KAAK,CAAC,CAAC,EAAEhB,QAAQ,CAAC,CAAC;EACxD,IAAI,CAACe,KAAK,EAAE;IACV;IACA,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAI5C,MAAM,EAAE;IAAE,OAAO,IAAI;EAAC;EAE1B,IAAI,OAAOH,KAAK,CAACiD,GAAG,CAACC,UAAU,KAAK,WAAW,EAAE;IAC/ClD,KAAK,CAACiD,GAAG,CAACC,UAAU,GAAG,CAAC,CAAC;EAC3B;EACA,IAAI,OAAOlD,KAAK,CAACiD,GAAG,CAACC,UAAU,CAACH,KAAK,CAAC,KAAK,WAAW,EAAE;IACtD/C,KAAK,CAACiD,GAAG,CAACC,UAAU,CAACH,KAAK,CAAC,GAAG;MAAED,KAAK;MAAER;IAAK,CAAC;EAC/C;EAEAtC,KAAK,CAACuB,UAAU,GAAGD,aAAa;EAEhCtB,KAAK,CAACmD,IAAI,GAAGlD,SAAS,GAAGG,KAAK,GAAG,CAAC;EAClC,OAAO,IAAI;AACb"},"metadata":{},"sourceType":"module","externalDependencies":[]}