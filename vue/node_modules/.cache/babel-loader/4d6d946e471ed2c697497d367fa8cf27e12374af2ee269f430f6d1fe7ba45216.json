{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Inline parser state\n\nimport Token from '../token.mjs';\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs';\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n\n  // backtick length => last seen position\n  this.backticks = {};\n  this.backticksScanned = false;\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0;\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n  const token = new Token(type, tag, nesting);\n  let token_meta = null;\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n  token.level = this.level;\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = {\n      delimiters: this.delimiters\n    };\n  }\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  let can_open, can_close;\n  let left_flanking = true;\n  let right_flanking = true;\n  const max = this.posMax;\n  const marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n  let pos = start;\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  const count = pos - start;\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  const isLastWhiteSpace = isWhiteSpace(lastChar);\n  const isNextWhiteSpace = isWhiteSpace(nextChar);\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n  if (!canSplitWord) {\n    can_open = left_flanking && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking || isNextPunctChar);\n  } else {\n    can_open = left_flanking;\n    can_close = right_flanking;\n  }\n  return {\n    can_open,\n    can_close,\n    length: count\n  };\n};\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\nexport default StateInline;","map":{"version":3,"names":["Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","backticks","backticksScanned","linkLevel","prototype","pushPending","token","content","push","type","tag","nesting","token_meta","pop","scanDelims","start","canSplitWord","can_open","can_close","left_flanking","right_flanking","max","marker","charCodeAt","lastChar","count","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace"],"sources":["C:/Users/wcf/springboot-vue框架实操/xm-blog/vue/node_modules/markdown-it/lib/rules_inline/state_inline.mjs"],"sourcesContent":["// Inline parser state\n\nimport Token from '../token.mjs'\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new Token(type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  let can_open, can_close\n  let left_flanking = true\n  let right_flanking = true\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = isWhiteSpace(lastChar)\n  const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n  if (isNextWhiteSpace) {\n    left_flanking = false\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar)\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar)\n  } else {\n    can_open  = left_flanking\n    can_close = right_flanking\n  }\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token\n\nexport default StateInline\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}